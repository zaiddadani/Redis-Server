/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Paths;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import redis.resp.RespException;
import redis.resp.RespScanner;
import redis.resp.types.RespNull;

class RespTypeTests {

    private Reader reader;

    void ReadReader(String testfile) throws FileNotFoundException, URISyntaxException {
        URL resource = RespTypeTests.class.getResource("tests/" + testfile);
        File file = Paths.get(resource.toURI()).toFile();
        reader = new FileReader(file);
    }

    @AfterEach
    void CloseReader() throws IOException {
        if (reader != null) {
            reader.close();
        }
    }

    @Test
    void next_null_expectnull() throws URISyntaxException, IOException, RespException {

        // Arrange
        var scanner = new RespScanner("$-1\r\n");

        // Act
        var type = scanner.next();

        // Assert
        assertEquals(RespNull.NULL, type.get(), "should be null");
    }

    @ParameterizedTest
    @CsvSource({
            "valid, step1, 1",
            "valid, step1, 2",
            "valid, step1, 3",
            "invalid, step1, 1",
            "invalid, step1, 2"
    })
    void validX_stepX_expectok(String type, String step, int index)
            throws URISyntaxException, IOException, RespException {
        ReadReader(step + "/" + type + index + ".txt");

        try (BufferedReader br = new BufferedReader(reader)) {
            String line;
            while ((line = br.readLine()) != null) {
                // Arrange
                var escapedLine = RespScanner.convertNewLines(line);
                var scanner = new RespScanner(escapedLine);

                if (type.equals("valid")) {
                    // Act
                    var respType = scanner.next();
                    if (respType.isEmpty()) {
                        fail("error while parsing type");
                    }
                    var escapedRespString = respType.get().toRespString();
                    var respString = RespScanner.convertNewLinesBack(escapedRespString);

                    // Assert
                    assertEquals(line, respString, "should be the same than '" + line + "'");

                } else {
                    assertThrows(RespException.class, () -> {
                        var respType = scanner.next();
                        if (respType.isEmpty()) {
                            throw new RespException("error while parsing type");
                        } else {
                            if (scanner.hasNext()) {
                                throw new RespException("resp protocol contains more elements than expected");
                            }

                        }
                    });
                }
            }
        }

    }

}
